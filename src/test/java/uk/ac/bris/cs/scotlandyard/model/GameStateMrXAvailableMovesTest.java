package uk.ac.bris.cs.scotlandyard.model;

import com.google.common.collect.ImmutableList;

import org.junit.Test;

import uk.ac.bris.cs.scotlandyard.model.Board.GameState;

import static org.assertj.core.api.Assertions.assertThat;
import static uk.ac.bris.cs.scotlandyard.model.Piece.Detective.BLUE;
import static uk.ac.bris.cs.scotlandyard.model.Piece.MrX.MRX;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.Ticket.BUS;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.Ticket.SECRET;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.Ticket.TAXI;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.defaultDetectiveTickets;


/**
 * Tests whether valid moves are generated by the game state
 */
public class GameStateMrXAvailableMovesTest extends ParameterisedModelTestBase {


	// MrX related tests

	@Test public void testMrXDoubleMoveIntermediateMovesOmittedIfDestinationOccupiedByDetectives() {
		var mrX = new Player(MRX, makeTickets(4, 3, 3, 2, 5), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 116);

		// no destination should end up at 116(blue), applies for first move and
		// second move
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				secret(MRX, 104, 86),
				x2(MRX, 104, TAXI, 86, BUS, 52),
				x2(MRX, 104, TAXI, 86, SECRET, 52),
				x2(MRX, 104, TAXI, 86, TAXI, 69),
				x2(MRX, 104, TAXI, 86, SECRET, 69),
				x2(MRX, 104, TAXI, 86, BUS, 87),
				x2(MRX, 104, TAXI, 86, SECRET, 87),
				x2(MRX, 104, TAXI, 86, BUS, 102),
				x2(MRX, 104, TAXI, 86, SECRET, 102),
				x2(MRX, 104, TAXI, 86, TAXI, 103),
				x2(MRX, 104, TAXI, 86, SECRET, 103),
				x2(MRX, 104, TAXI, 86, TAXI, 104),
				x2(MRX, 104, TAXI, 86, SECRET, 104),
				x2(MRX, 104, SECRET, 86, BUS, 52),
				x2(MRX, 104, SECRET, 86, SECRET, 52),
				x2(MRX, 104, SECRET, 86, TAXI, 69),
				x2(MRX, 104, SECRET, 86, SECRET, 69),
				x2(MRX, 104, SECRET, 86, BUS, 87),
				x2(MRX, 104, SECRET, 86, SECRET, 87),
				x2(MRX, 104, SECRET, 86, BUS, 102),
				x2(MRX, 104, SECRET, 86, SECRET, 102),
				x2(MRX, 104, SECRET, 86, TAXI, 103),
				x2(MRX, 104, SECRET, 86, SECRET, 103),
				x2(MRX, 104, SECRET, 86, TAXI, 104),
				x2(MRX, 104, SECRET, 86, SECRET, 104));
	}

	@Test public void testMrXMovesOmittedIfDestinationOccupiedByDetectives() {
		var mrX = new Player(MRX, makeTickets(4, 3, 3, 0, 5), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 116);

		// no destination should end up at 116(blue) and no double move
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				secret(MRX, 104, 86));
	}

	@Test public void testMrXMustHaveEnoughTicketsForDoubleMove() {
		var mrX = new Player(MRX, makeTickets(1, 1, 0, 2, 0), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);
		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				// no repeated tickets with double move for taxi and bus because
				// we only
				// have one of each
				taxi(MRX, 104, 86),
				taxi(MRX, 104, 116),
				x2(MRX, 104, TAXI, 86, BUS, 52),
				x2(MRX, 104, TAXI, 86, BUS, 87),
				x2(MRX, 104, TAXI, 86, BUS, 102),
				x2(MRX, 104, TAXI, 86, BUS, 116),
				x2(MRX, 104, TAXI, 116, BUS, 86),
				x2(MRX, 104, TAXI, 116, BUS, 108),
				x2(MRX, 104, TAXI, 116, BUS, 127),
				x2(MRX, 104, TAXI, 116, BUS, 142));
	}

	@Test public void testMrXNoSecretMovesIfNoSecretMoveTickets() {
		var mrX = new Player(MRX, makeTickets(4, 3, 3, 2, 0), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);
		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				taxi(MRX, 104, 116),
				x2(MRX, 104, TAXI, 86, BUS, 52),
				x2(MRX, 104, TAXI, 86, TAXI, 69),
				x2(MRX, 104, TAXI, 86, BUS, 87),
				x2(MRX, 104, TAXI, 86, BUS, 102),
				x2(MRX, 104, TAXI, 86, TAXI, 103),
				x2(MRX, 104, TAXI, 86, TAXI, 104),
				x2(MRX, 104, TAXI, 86, BUS, 116),
				x2(MRX, 104, TAXI, 116, BUS, 86),
				x2(MRX, 104, TAXI, 116, TAXI, 104),
				x2(MRX, 104, TAXI, 116, BUS, 108),
				x2(MRX, 104, TAXI, 116, TAXI, 118),
				x2(MRX, 104, TAXI, 116, TAXI, 127),
				x2(MRX, 104, TAXI, 116, BUS, 127),
				x2(MRX, 104, TAXI, 116, BUS, 142));
	}

	@Test public void testMrXNoDoubleMovesIfNoDoubleMoveTickets() {
		var mrX = new Player(MRX, makeTickets(4, 3, 3, 0, 5), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);

		// no double move generated if no double move tickets
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				secret(MRX, 104, 86),
				taxi(MRX, 104, 116),
				secret(MRX, 104, 116));
	}

	@Test public void testMrXNoDoubleMovesIfNotEnoughMovesLeft() {
		var mrX = new Player(MRX, makeTickets(4, 3, 3, 2, 5), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);

		// no double move because we have no next round to play the second move
		GameState state = gameStateFactory.build(
				new GameSetup(standardGraph(), ImmutableList.of(true)),
				mrX, blue);

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				secret(MRX, 104, 86),
				taxi(MRX, 104, 116),
				secret(MRX, 104, 116));
	}

	@Test public void testMrXNoTicketMovesIfNoTicketMoveTickets() {
		var mrX = new Player(MRX, makeTickets(1, 0, 1, 0, 0), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);

		// no bus moves as there are no bus tickets
		GameState state = gameStateFactory.build(
				new GameSetup(standardGraph(), ImmutableList.of(true)),
				mrX, blue);

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				taxi(MRX, 104, 116));
	}

	@Test public void testMrXOnlySecretMovesIfOnlySecretMoveTicketsLeft() {
		var mrX = new Player(MRX, makeTickets(0, 0, 0, 0, 1), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);

		// only secret moves if only secret move ticket left
		GameState state = gameStateFactory.build(
				new GameSetup(standardGraph(), ImmutableList.of(true)),
				mrX, blue);

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				secret(MRX, 104, 86),
				secret(MRX, 104, 116));
	}

	@Test public void testMrXAt104ShouldProduce60ValidMoves() {
		var mrX = new Player(MRX, makeTickets(4, 3, 3, 2, 5), 104);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 117);

		// 60 moves in total, note the permutation pattern and relation of DoubleMove to TicketMove
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);
		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(MRX, 104, 86),
				x2(MRX, 104, TAXI, 86, TAXI, 104),
				x2(MRX, 104, TAXI, 86, SECRET, 104),
				x2(MRX, 104, TAXI, 86, BUS, 52),
				x2(MRX, 104, TAXI, 86, SECRET, 52),
				x2(MRX, 104, TAXI, 86, BUS, 116),
				x2(MRX, 104, TAXI, 86, SECRET, 116),
				x2(MRX, 104, TAXI, 86, TAXI, 69),
				x2(MRX, 104, TAXI, 86, SECRET, 69),
				x2(MRX, 104, TAXI, 86, BUS, 102),
				x2(MRX, 104, TAXI, 86, SECRET, 102),
				x2(MRX, 104, TAXI, 86, BUS, 87),
				x2(MRX, 104, TAXI, 86, SECRET, 87),
				x2(MRX, 104, TAXI, 86, TAXI, 103),
				x2(MRX, 104, TAXI, 86, SECRET, 103),
				secret(MRX, 104, 86),
				x2(MRX, 104, SECRET, 86, TAXI, 104),
				x2(MRX, 104, SECRET, 86, SECRET, 104),
				x2(MRX, 104, SECRET, 86, BUS, 52),
				x2(MRX, 104, SECRET, 86, SECRET, 52),
				x2(MRX, 104, SECRET, 86, BUS, 116),
				x2(MRX, 104, SECRET, 86, SECRET, 116),
				x2(MRX, 104, SECRET, 86, TAXI, 69),
				x2(MRX, 104, SECRET, 86, SECRET, 69),
				x2(MRX, 104, SECRET, 86, BUS, 102),
				x2(MRX, 104, SECRET, 86, SECRET, 102),
				x2(MRX, 104, SECRET, 86, BUS, 87),
				x2(MRX, 104, SECRET, 86, SECRET, 87),
				x2(MRX, 104, SECRET, 86, TAXI, 103),
				x2(MRX, 104, SECRET, 86, SECRET, 103),
				taxi(MRX, 104, 116),
				x2(MRX, 104, TAXI, 116, TAXI, 104),
				x2(MRX, 104, TAXI, 116, SECRET, 104),
				x2(MRX, 104, TAXI, 116, BUS, 108),
				x2(MRX, 104, TAXI, 116, SECRET, 108),
				x2(MRX, 104, TAXI, 116, BUS, 86),
				x2(MRX, 104, TAXI, 116, SECRET, 86),
				x2(MRX, 104, TAXI, 116, TAXI, 118),
				x2(MRX, 104, TAXI, 116, SECRET, 118),
				x2(MRX, 104, TAXI, 116, BUS, 142),
				x2(MRX, 104, TAXI, 116, SECRET, 142),
				x2(MRX, 104, TAXI, 116, TAXI, 127),
				x2(MRX, 104, TAXI, 116, SECRET, 127),
				x2(MRX, 104, TAXI, 116, BUS, 127),
				secret(MRX, 104, 116),
				x2(MRX, 104, SECRET, 116, TAXI, 104),
				x2(MRX, 104, SECRET, 116, SECRET, 104),
				x2(MRX, 104, SECRET, 116, BUS, 108),
				x2(MRX, 104, SECRET, 116, SECRET, 108),
				x2(MRX, 104, SECRET, 116, BUS, 86),
				x2(MRX, 104, SECRET, 116, SECRET, 86),
				x2(MRX, 104, SECRET, 116, TAXI, 118),
				x2(MRX, 104, SECRET, 116, SECRET, 118),
				x2(MRX, 104, SECRET, 116, BUS, 142),
				x2(MRX, 104, SECRET, 116, SECRET, 142),
				x2(MRX, 104, SECRET, 116, TAXI, 127),
				x2(MRX, 104, SECRET, 116, SECRET, 127),
				x2(MRX, 104, SECRET, 116, BUS, 127));
	}


}
