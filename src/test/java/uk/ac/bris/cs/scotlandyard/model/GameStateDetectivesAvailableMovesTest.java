package uk.ac.bris.cs.scotlandyard.model;

import org.junit.Test;

import uk.ac.bris.cs.scotlandyard.model.Board.GameState;

import static org.assertj.core.api.Assertions.assertThat;
import static uk.ac.bris.cs.scotlandyard.model.Piece.Detective.BLUE;
import static uk.ac.bris.cs.scotlandyard.model.Piece.Detective.GREEN;
import static uk.ac.bris.cs.scotlandyard.model.Piece.Detective.RED;
import static uk.ac.bris.cs.scotlandyard.model.Piece.Detective.WHITE;
import static uk.ac.bris.cs.scotlandyard.model.Piece.Detective.YELLOW;
import static uk.ac.bris.cs.scotlandyard.model.Piece.MrX.MRX;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.Ticket.BUS;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.Ticket.TAXI;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.defaultDetectiveTickets;
import static uk.ac.bris.cs.scotlandyard.model.ScotlandYard.defaultMrXTickets;


/**
 * Tests whether valid moves are generated by the game state
 * <br>
 * <b>IMPORTANT: {@link GameState#advance(Move)} must be properly implemented for any of the
 * tests here to work properly!</b>
 */
public class GameStateDetectivesAvailableMovesTest extends ParameterisedModelTestBase {

	// -- Detective related tests --


	@Test public void testDetectiveAt128MovesShouldProduce13ValidMoves() {
		var mrX = new Player(MRX, defaultMrXTickets(), 104);
		var blue = new Player(BLUE, makeTickets(11, 8, 4, 0, 0), 128);

		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);
		state = state.advance(taxi(MRX, 104, 86));
		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				underground(BLUE, 128, 89),
				underground(BLUE, 128, 185),
				underground(BLUE, 128, 140),
				bus(BLUE, 128, 187),
				bus(BLUE, 128, 199),
				bus(BLUE, 128, 135),
				bus(BLUE, 128, 142),
				bus(BLUE, 128, 161),
				taxi(BLUE, 128, 188),
				taxi(BLUE, 128, 142),
				taxi(BLUE, 128, 143),
				taxi(BLUE, 128, 160),
				taxi(BLUE, 128, 172));
	}

	@Test public void testMultipleDetectivesShouldProduceValidMoves() {
		var mrX = new Player(MRX, defaultMrXTickets(), 106);
		var red = new Player(RED, defaultDetectiveTickets(), 91);
		var green = new Player(GREEN, defaultDetectiveTickets(), 29);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 94);
		var white = new Player(WHITE, defaultDetectiveTickets(), 50);
		var yellow = new Player(YELLOW, defaultDetectiveTickets(), 138);

		GameState state = gameStateFactory.build(standard24MoveSetup(),
				mrX, red, green, blue, white, yellow);
		state = state
				.advance(x2(MRX, 106, TAXI, 105, BUS, 87));

		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(taxi(RED, 91, 56),
				taxi(RED, 91, 72),
				taxi(RED, 91, 105),
				taxi(RED, 91, 90),
				taxi(RED, 91, 107),
				taxi(GREEN, 29, 16),
				taxi(GREEN, 29, 17),
				taxi(GREEN, 29, 41),
				bus(GREEN, 29, 41),
				taxi(GREEN, 29, 42),
				bus(GREEN, 29, 42),
				taxi(GREEN, 29, 6),
				bus(GREEN, 29, 15),
				bus(GREEN, 29, 55),
				bus(BLUE, 94, 74),
				taxi(BLUE, 94, 75),
				bus(BLUE, 94, 77),
				taxi(BLUE, 94, 93),
				bus(BLUE, 94, 93),
				taxi(BLUE, 94, 95),
				taxi(WHITE, 50, 37),
				taxi(WHITE, 50, 49),
				taxi(WHITE, 50, 38),
				taxi(YELLOW, 138, 124),
				taxi(YELLOW, 138, 152),
				taxi(YELLOW, 138, 150));
	}

	@Test public void testDetectiveMovesOmittedIfNotEnoughTickets() {
		var mrX = new Player(MRX, defaultMrXTickets(), 104);
		var blue = new Player(BLUE, makeTickets(0, 8, 4, 0, 0), 128);

		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);
		state = state.advance(taxi(MRX, 104, 86));
		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				underground(BLUE, 128, 89),
				underground(BLUE, 128, 185),
				underground(BLUE, 128, 140),
				bus(BLUE, 128, 187),
				bus(BLUE, 128, 199),
				bus(BLUE, 128, 135),
				bus(BLUE, 128, 142),
				bus(BLUE, 128, 161));
	}

	@Test public void testDetectiveWithNoValidMovesShouldProduceNoMove() {
		var mrX = new Player(MRX, defaultMrXTickets(), 104);
		var red = new Player(RED, defaultDetectiveTickets(), 111);
		var blue = new Player(BLUE, makeTickets(0, 0, 0, 0, 0), 128);

		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, red, blue);
		state = state.advance(taxi(MRX, 104, 86));
		state = state.advance(taxi(RED, 111, 124));
		// moves are from blue as red has no more tickets
		assertThat(state.getAvailableMoves()).noneMatch(m -> m.commencedBy() == BLUE);
	}

	@Test public void testDetectiveMoveOmittedIfLocationOccupiedByOtherDetective() {
		// this happens around london zoo where an awkward taxi route appears
		// around location 2
		var mrX = new Player(MRX, defaultMrXTickets(), 104);
		var red = new Player(RED, makeTickets(0, 0, 0, 0, 0), 10);
		var green = new Player(GREEN, defaultDetectiveTickets(), 2);

		// green can only move to 20 because 10 is blocked
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, red, green);
		state = state.advance(taxi(MRX, 104, 86));
		assertThat(state.getAvailableMoves())
				.containsExactly(taxi(GREEN, 2, 20));
	}

	@Test public void testDetectiveMoveOmittedIfAlreadyPlayed() {
		var mrX = new Player(MRX, defaultMrXTickets(), 104);
		var red = new Player(RED, defaultDetectiveTickets(), 116);
		var green = new Player(GREEN, defaultDetectiveTickets(), 2);
		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, red, green);
		state = state.advance(taxi(MRX, 104, 86));
		state = state.advance(taxi(GREEN, 2, 20));
		assertThat(state.getAvailableMoves()).noneMatch(m -> m.commencedBy() == GREEN);
		state = state.advance(bus(RED, 116, 127));
		assertThat(state.getAvailableMoves())
				.noneMatch(m -> m.commencedBy() == GREEN)
				.noneMatch(m -> m.commencedBy() == RED);
	}

	@Test public void testDetectiveMoveNotOmittedIfDestinationOccupiedByMrX() {
		var mrX = new Player(MRX, defaultMrXTickets(), 86);
		var blue = new Player(BLUE, defaultDetectiveTickets(), 85);

		GameState state = gameStateFactory.build(standard24MoveSetup(), mrX, blue);
		state = state.advance(taxi(MRX, 86, 103));
		// MrX's location should be a valid destination, where he will be caught
		assertThat(state.getAvailableMoves()).containsExactlyInAnyOrder(
				taxi(BLUE, 85, 103),
				taxi(BLUE, 85, 68),
				taxi(BLUE, 85, 84));
	}


}
